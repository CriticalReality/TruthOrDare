<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Truth or Dare — PeerJS Multiplayer (fixed)</title>
  <style>
    :root{--bg:#000;--fg:#ddd;--muted:#888}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
    .app{display:flex;flex-direction:column;height:100%;gap:12px;padding:18px}
    .center{margin:auto}
    .btn{background:#222;border:1px solid #444;padding:10px 14px;border-radius:8px;color:var(--fg);cursor:pointer;min-width:120px;transition:transform .12s ease,opacity .12s}
    .btn:hover{transform:translateY(-3px)}
    .muted{color:var(--muted)}
    input,select{background:#111;border:1px solid #333;padding:8px;border-radius:8px;color:var(--fg)}
    .menu{display:flex;gap:12px;align-items:center}
    .menu .box{background:rgba(255,255,255,0.02);padding:20px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .room{display:grid;grid-template-columns:300px 1fr 300px;gap:12px;align-items:start}
    .panel{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .players{display:flex;flex-direction:column;gap:8px}
    .player{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px}
    .swatch{width:36px;height:36px;border-radius:8px;flex:0 0 36px}
    .cards{display:flex;flex-direction:column;gap:8px}
    .card{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .timer{display:flex;align-items:center;gap:10px}
    .ring{width:64px;height:64px;border-radius:50%;position:relative}
    .ring .fill{position:absolute;inset:0;border-radius:50%;box-shadow:inset 0 0 0 6px rgba(255,255,255,0.06)}
    .count{font-size:20px}
    .fade-in{animation:fadeIn .28s ease both}
    @keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:none}}
    @media (max-width:900px){.room{grid-template-columns:1fr;}.panel{width:100%}}
    footer{opacity:.6;font-size:13px}
    button:disabled{opacity:0.5;cursor:not-allowed}

    /* Circular avatars */
    #circleArea{position:relative;height:320px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);display:flex;align-items:center;justify-content:center}
    .avatar{position:absolute;display:flex;flex-direction:column;align-items:center;gap:6px;width:84px}
    .avatar .dot{width:56px;height:56px;border-radius:50%;display:inline-block;border:3px solid rgba(255,255,255,0.06);box-sizing:border-box}
    .avatar .label{font-size:12px;text-align:center;width:80px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    #centerArrow{position:absolute;width:10px;height:120px;left:50%;top:50%;transform-origin:50% 80%;margin-left:-5px;margin-top:-60px;pointer-events:none}
    #centerArrow .shaft{width:4px;height:70px;background:var(--fg);margin:0 auto;border-radius:3px;opacity:0.9}
    #centerArrow .head{width:0;height:0;border-left:10px solid transparent;border-right:10px solid transparent;border-top:18px solid var(--fg);margin-top:-4px;opacity:0.95}

    /* Card display */
    #cardDisplay{margin-top:12px;padding:12px;border-radius:8px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.03);min-height:60px}
    .modal{position:fixed;left:0;right:0;top:0;bottom:0;background:rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center}
    .modal .box{background:#0a0a0a;padding:16px;border-radius:10px;border:1px solid rgba(255,255,255,0.04);width:420px;max-width:94%}
    .small{font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1 style="margin:0">Truth or Dare — PeerJS Multiplayer</h1>
      <p class="muted">No backend required — uses PeerJS cloud for peer discovery and data connections.</p>
    </header>

    <main class="center">
      <div id="menu" class="menu box fade-in">
        <div>
          <div style="margin-bottom:8px">Display name</div>
          <input id="nameInput" placeholder="Your name" value="Player" />
        </div>
        <div style="display:flex;flex-direction:column;gap:8px">
          <button id="createBtn" class="btn">Create Room</button>
          <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
            <input id="joinId" placeholder="Room ID" />
            <button id="joinBtn" class="btn">Join Room</button>
          </div>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px">
          <label class="muted">Rounds</label>
          <select id="roundsSelect">
            <option value="3">3</option>
            <option value="5" selected>5</option>
            <option value="7">7</option>
          </select>
          <div class="muted" style="font-size:12px;margin-top:6px">Tip: copy the Room ID and paste in Discord for friends to join.</div>
        </div>
      </div>

      <div id="roomUI" style="display:none;width:95vw;max-width:1100px" class="fade-in">
        <div style="margin-bottom:10px;display:flex;justify-content:space-between;gap:12px;align-items:center">
          <div><strong>Room:</strong> <span id="roomIdDisplay"></span></div>
          <div class="muted">You are <span id="youName"></span> · <span id="youId"></span></div>
        </div>

        <div class="room">
          <div class="panel">
            <h3>Players</h3>
            <div id="playersList" class="players"></div>
            <div style="margin-top:8px"><button id="leaveBtn" class="btn">Leave Room</button></div>
          </div>

          <div class="panel">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
              <h3>Game Area</h3>
              <div style="display:flex;gap:8px;align-items:center">
                <label class="muted">Round</label>
                <div id="roundDisplay">0 / 0</div>
                <button id="startRoundBtn" class="btn">Start Round</button>
              </div>
            </div>

            <div id="mainStage" style="margin-top:12px">
              <div id="circleArea">
                <!-- avatars are injected here -->
                <div id="centerArrow">
                  <div class="shaft"></div>
                  <div class="head"></div>
                </div>
              </div>

              <div id="cardDisplay" style="display:none"></div>

              <div id="turnInfo" style="display:none;margin-top:10px">
                <div><strong>Target:</strong> <span id="targetName"></span></div>
                <div style="margin-top:8px" class="timer">
                  <div class="ring"><div id="ringFill" class="fill"></div></div>
                  <div><div class="count" id="timeLeft">0</div><div class="muted">seconds left</div></div>
                </div>
              </div>

              <div id="votePanel" style="display:none;margin-top:12px">
                <div class="muted">Vote: Did they complete the challenge?</div>
                <div style="display:flex;gap:8px;margin-top:8px">
                  <button class="btn" id="voteYes">Success</button>
                  <button class="btn" id="voteNo">Fail</button>
                </div>
              </div>

              <div id="chooseTargetPanel" style="display:none;margin-top:12px">
                <div class="muted">Choose next target</div>
                <div id="chooseList" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"></div>
              </div>

              <div id="gameOver" style="display:none;margin-top:12px">
                <h3>Game Over</h3>
                <div id="winnerText" class="muted"></div>
              </div>
            </div>

          </div>

          <div class="panel">
            <h3 class="small">(Optional) Your Cards — unused in immediate gameplay</h3>
            <div style="display:flex;gap:8px;margin-bottom:8px">
              <input id="cardText" placeholder="Write a truth or dare" style="flex:1" />
              <select id="cardType"><option value="truth">Truth</option><option value="dare">Dare</option></select>
              <button id="addCardBtn" class="btn">Add</button>
            </div>
            <div id="yourCards" class="cards" style="max-height:320px;overflow:auto"></div>
            <hr style="opacity:.06;margin:10px 0" />
            <div class="muted" style="font-size:13px">Room colors</div>
            <div style="height:40px;display:flex;gap:8px;align-items:center;margin-top:6px">
              <div id="accentA" style="width:40px;border-radius:6px"></div>
              <div id="accentB" style="width:40px;border-radius:6px"></div>
            </div>
          </div>
        </div>

      </div>
    </main>

    <footer>Built with PeerJS cloud — open-source; save this file as index.html and host on GitHub Pages for easy sharing.</footer>
  </div>

  <!-- PeerJS CDN -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    /* --- utilities & UI refs --- */
    const qs = sel => document.querySelector(sel);
    const randColor = () => '#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');

    const menu = qs('#menu'), roomUI = qs('#roomUI');
    const nameInput = qs('#nameInput'), createBtn = qs('#createBtn'), joinBtn = qs('#joinBtn'), joinId = qs('#joinId');
    const roomIdDisplay = qs('#roomIdDisplay'), youName = qs('#youName'), youId = qs('#youId');
    const playersList = qs('#playersList'), yourCards = qs('#yourCards'), addCardBtn = qs('#addCardBtn'), cardText = qs('#cardText'), cardType = qs('#cardType');
    const startRoundBtn = qs('#startRoundBtn'), roundDisplay = qs('#roundDisplay');
    const turnInfo = qs('#turnInfo'), targetName = qs('#targetName'), timeLeft = qs('#timeLeft'), ringFill = qs('#ringFill');
    const votePanel = qs('#votePanel'), voteYes = qs('#voteYes'), voteNo = qs('#voteNo');
    const choosePanel = qs('#chooseTargetPanel'), chooseList = qs('#chooseList');
    const roundsSelect = qs('#roundsSelect'), leaveBtn = qs('#leaveBtn');
    const accentA = qs('#accentA'), accentB = qs('#accentB');
    const gameOver = qs('#gameOver'), winnerText = qs('#winnerText');
    const circleArea = qs('#circleArea'), centerArrow = qs('#centerArrow'), cardDisplay = qs('#cardDisplay');

    /* --- network & state --- */
    let peer = null;
    let connMap = {}; // remotePeerId -> DataConnection (host: connections to clients)
    let isHost = false;
    let localId = null;
    let displayName = 'Player';

    let roomState = {
      id: null,
      players: {}, // peerId -> {name, cards:[], score:0, color}
      round: 0,
      maxRounds: 5,
      currentTarget: null,
      previousTarget: null,
      asker: null,
      status: 'lobby' // 'lobby'|'awaiting_card'|'running'|'voting'|'choose'|'over'
    };

    let clientState = null;

    let countdownTimer = null;

    /* --- Peer helpers --- */
    function makePeer() {
      if (peer) return;
      peer = new Peer();

      peer.on('open', id => {
        localId = id;
        youId.textContent = id;
        console.log('peer open', id);
      });

      peer.on('connection', conn => {
        if (!isHost) { conn.on('open', () => conn.close()); return; }
        setupConn(conn);
      });

      peer.on('error', err => console.error('Peer error', err));
      peer.on('disconnected', ()=> console.warn('peer disconnected'));
      peer.on('close', ()=> console.warn('peer closed'));
    }

    function setupConn(conn) {
      conn.on('data', data => handleMessage(conn.peer, data));
      conn.on('open', ()=> {
        connMap[conn.peer] = conn;
        // send state to new client immediately
        if (isHost) {
          sendTo(conn, {type:'state', payload:roomState});
          renderPlayers();
        }
      });
      conn.on('close', ()=> {
        delete connMap[conn.peer];
        if (isHost) {
          delete roomState.players[conn.peer];
          if (roomState.currentTarget === conn.peer) roomState.currentTarget = null;
          if (roomState.previousTarget === conn.peer) roomState.previousTarget = null;
          if (roomState.asker === conn.peer) roomState.asker = null;
          broadcast({type:'state', payload:roomState});
          renderPlayers();
        }
      });
      conn.on('error', err => console.warn('conn error', err));
    }

    function connectToHost(hostId) {
      if (!peer || !localId) return alert('peer not ready yet');
      const c = peer.connect(hostId, {reliable:true});
      c.on('open', ()=> {
        setupConn(c);
        sendTo(c,{type:'join', payload:{name:displayName}});
      });
      c.on('error', e=>console.error('connect error', e));
    }

    function sendTo(connOrPeerId, msg) {
      if (typeof connOrPeerId === 'string') {
        const c = connMap[connOrPeerId];
        if (c && c.open) c.send(msg);
        return;
      }
      if (connOrPeerId && connOrPeerId.open) connOrPeerId.send(msg);
    }

    function broadcast(msg) {
      Object.values(connMap).forEach(c => { if (c.open) c.send(msg); });
    }

    /* --- message handling --- */
    function handleMessage(fromPeerId, msg) {
      try {
        const {type, payload} = msg || {};
        if (isHost) return hostHandle(fromPeerId, type, payload);
        return clientHandle(type, payload, fromPeerId);
      } catch(e){ console.error('msg handle err', e); }
    }

    /* Host-side handlers */
    function hostHandle(peerId, type, payload){
      if (type === 'join') {
        if (!roomState.players[peerId]) {
          roomState.players[peerId] = { name: payload.name || 'Player', cards: [], score: 0, color: randColor() };
          broadcast({type:'state', payload:roomState});
          renderPlayers();
        }
      } else if (type === 'add_card') {
        const card = {...payload.card, owner: peerId, id: Date.now() + Math.random()};
        if (roomState.players[peerId]) {
          roomState.players[peerId].cards.push(card);
          broadcast({type:'state', payload:roomState});
          renderPlayers();
        }
      } else if (type === 'start_turn') {
        // choose asker & target were chosen at host action; this message may not be used by clients to start timer
        // KEEP for backward compat if clients send start_turn
      } else if (type === 'present_card') {
        // asker presented a card
        const card = {...payload.card, id: Date.now()+Math.random(), asker: peerId, targetId: payload.targetId};
        roomState.lastCard = card;
        roomState.status = 'running';
        const duration = payload.duration || 20;
        const endTime = Date.now() + duration*1000;
        // broadcast the card and start timer
        broadcast({type:'card_presented', payload:{card, targetId: card.targetId}});
        broadcast({type:'start_timer', payload:{endTime, duration, targetId: card.targetId}});
        broadcast({type:'state', payload:roomState});
        // also process locally on host UI
        clientHandle('card_presented', {card, targetId: card.targetId});
        clientHandle('start_timer', {endTime, duration, targetId: card.targetId});
      } else if (type === 'vote') {
        roomState.votes = roomState.votes || {};
        roomState.votes[peerId] = payload.vote;
        const totalPlayers = Object.keys(roomState.players).length;
        if (Object.keys(roomState.votes).length >= totalPlayers) {
          const yes = Object.values(roomState.votes).filter(Boolean).length;
          const success = yes > (totalPlayers/2);
          if (success && roomState.currentTarget && roomState.players[roomState.currentTarget]) {
            roomState.players[roomState.currentTarget].score = (roomState.players[roomState.currentTarget].score || 0) + 1;
          }
          roomState.status = 'choose';
          broadcast({type:'vote_result', payload:{success, votes: roomState.votes}});
          broadcast({type:'state', payload:roomState});
          roomState.votes = {};
        }
      } else if (type === 'choose_target') {
        const newTarget = payload.newTarget;
        const prev = roomState.currentTarget;
        roomState.previousTarget = prev;
        roomState.currentTarget = newTarget;
        roomState.asker = null;
        roomState.round = (roomState.round || 0) + 1;
        // end condition
        if (roomState.round >= roomState.maxRounds) {
          roomState.status = 'over';
          let winner = null; let top = -1;
          Object.entries(roomState.players).forEach(([pid,p]) => { if ((p.score||0) > top) { top = p.score; winner = {id: pid, name: p.name, score: p.score}; }});
          broadcast({type:'game_over', payload:{winner}});
          broadcast({type:'state', payload:roomState});
          return;
        }
        // pick next asker (anyone except target)
        const pids = Object.keys(roomState.players || {});
        let askerChoices = pids.filter(id => id !== roomState.currentTarget);
        if (askerChoices.length === 0) askerChoices = pids;
        const nextAsker = askerChoices[Math.floor(Math.random()*askerChoices.length)];
        roomState.asker = nextAsker;
        roomState.status = 'awaiting_card';
        broadcast({type:'start_turn', payload:{targetId: roomState.currentTarget, askerId: nextAsker, round: roomState.round}});
        broadcast({type:'state', payload:roomState});
        // also notify host UI locally
        clientHandle('start_turn', {targetId: roomState.currentTarget, askerId: nextAsker, round: roomState.round});
      }
    }

    /* Client-side handlers */
    function clientHandle(type, payload, fromPeerId) {
      if (type === 'state') {
        clientState = payload;
        renderPlayers();
        updateYourCards();
        roundDisplay.textContent = (payload.round || 0) + ' / ' + (payload.maxRounds || 0);
        const players = payload.players || {};
        const colors = Object.values(players).map(p => p.color).filter(Boolean);
        accentA.style.background = colors[0] || '#444';
        accentB.style.background = colors[1] || '#666';
        // render arrow and circle immediately
        renderCirclePlayers(players, payload.currentTarget);
      } else if (type === 'start_turn') {
        clientState = clientState || {};
        clientState.currentTarget = payload.targetId;
        clientState.asker = payload.askerId || clientState.asker || null;
        // set label for target
        const tPlayers = clientState.players || {};
        const label = (tPlayers[payload.targetId] && tPlayers[payload.targetId].name) || (payload.targetId === localId ? 'You' : payload.targetId);
        targetName.textContent = label;
        // update circle arrow
        renderCirclePlayers(clientState.players || {}, payload.targetId);
        // if I'm the asker, prompt for a truth/dare now
        if (payload.askerId === localId) {
          showCardInput(payload.targetId);
        } else {
          // waiting state: clear card display and show waiting message if not target
          cardDisplay.style.display = 'none';
          turnInfo.style.display = 'none';
          votePanel.style.display = 'none';
        }
      } else if (type === 'card_presented') {
        // show card to all players immediately
        const card = payload.card;
        showPresentedCard(card);
      } else if (type === 'start_timer') {
        // only start timer for everyone (display target info, etc)
        const tPlayers = clientState && clientState.players || {};
        const label = (tPlayers[payload.targetId] && tPlayers[payload.targetId].name) || (payload.targetId === localId ? 'You' : payload.targetId);
        targetName.textContent = label;
        startCountdown(payload.endTime, payload.duration || 20);
      } else if (type === 'vote_result') {
        const s = payload.success;
        alert('Vote result: ' + (s ? 'SUCCESS' : 'FAILED'));
      } else if (type === 'game_over') {
        gameOver.style.display = 'block';
        winnerText.textContent = payload.winner ? (payload.winner.name + ' wins with ' + payload.winner.score + ' points') : 'No winner';
      }
    }

    /* --- UI actions --- */
    createBtn.onclick = async ()=> {
      displayName = nameInput.value.trim() || 'Player';
      isHost = true;
      makePeer();
      await waitForLocalId();
      roomState.id = localId;
      roomState.maxRounds = parseInt(roundsSelect.value, 10) || 5;
      roomState.players[localId] = { name: displayName, cards: [], score: 0, color: randColor() };

      menu.style.display = 'none'; roomUI.style.display = 'block';
      roomIdDisplay.textContent = localId; youName.textContent = displayName; youId.textContent = localId;
      renderPlayers();
      // host local state should be pushed to itself as well
      // (no DataConnection required for self)
    };

    joinBtn.onclick = ()=> {
      displayName = nameInput.value.trim() || 'Player';
      isHost = false;
      makePeer();
      const id = joinId.value.trim(); if (!id) return alert('enter room id');
      waitForLocalId().then(()=> {
        connectToHost(id);
        menu.style.display = 'none'; roomUI.style.display = 'block';
        roomIdDisplay.textContent = id; youName.textContent = displayName; youId.textContent = localId;
      });
    };

    async function waitForLocalId(){
      if (localId) return;
      return new Promise(r => {
        const t = setInterval(()=>{ if (localId){ clearInterval(t); r(); } }, 50);
      });
    }

    addCardBtn.onclick = ()=> {
      const text = cardText.value.trim(); if (!text) return;
      const ct = cardType.value;
      const card = {type:ct, text};
      if (isHost) {
        roomState.players[localId].cards.push({...card, id: Date.now()+Math.random(), owner: localId});
        broadcast({type:'state', payload: roomState});
        renderPlayers(); updateYourCards();
      } else {
        const hostConn = Object.values(connMap)[0];
        if (!hostConn) return alert('not connected to host');
        sendTo(hostConn, {type:'add_card', payload:{card}});
      }
      cardText.value = '';
    };

    startRoundBtn.onclick = ()=> {
      if (!isHost) return alert('only host may start rounds');
      const pids = Object.keys(roomState.players || {});
      if (pids.length < 2) return alert('need at least 2 players');
      // pick target & asker
      let choices = pids.filter(id => id !== roomState.previousTarget);
      if (choices.length === 0) choices = pids;
      const target = choices[Math.floor(Math.random()*choices.length)];
      // pick asker (anyone except target)
      let askerChoices = pids.filter(id => id !== target);
      if (askerChoices.length === 0) askerChoices = pids;
      const asker = askerChoices[Math.floor(Math.random()*askerChoices.length)];

      roomState.round = (roomState.round || 0) + 1;
      roomState.currentTarget = target;
      roomState.asker = asker;
      roomState.status = 'awaiting_card';
      roomState.maxRounds = parseInt(roundsSelect.value,10) || roomState.maxRounds;

      // broadcast start_turn (awaiting card)
      broadcast({type:'start_turn', payload:{targetId: target, askerId: asker, round: roomState.round}});
      broadcast({type:'state', payload: roomState});
      // also notify host client UI directly
      clientHandle('start_turn', {targetId: target, askerId: asker, round: roomState.round});
    };

    leaveBtn.onclick = ()=> { location.reload(); };

    /* --- rendering --- */
    function renderPlayers() {
      const state = isHost ? roomState : (clientState || {players:{}});

      playersList.innerHTML = '';
      Object.entries(state.players || {}).forEach(([pid, p]) => {
        const el = document.createElement('div'); el.className = 'player';
        const youTag = (pid === localId) ? ' <span class="muted">(you)</span>' : '';
        el.innerHTML = `<div class="swatch" style="background:${p.color}"></div><div style="flex:1"><div><strong>${p.name}</strong> ${youTag}</div><div class="muted" style="font-size:12px">Score: ${p.score||0} · Cards: ${p.cards? p.cards.length:0}</div></div>`;
        playersList.appendChild(el);
      });

      // show choose target if in choose state and currentTarget is this client
      if (!isHost && clientState && clientState.status === 'choose' && clientState.currentTarget === localId) {
        showChooseTargets(clientState.players);
      } else {
        choosePanel.style.display = 'none';
      }

      const colors = Object.values(state.players || {}).map(p => p.color).filter(Boolean);
      accentA.style.background = colors[0] || '#333';
      accentB.style.background = colors[1] || '#555';

      // update circle visuals
      const players = state.players || {};
      renderCirclePlayers(players, state.currentTarget);
    }

    function updateYourCards() {
      const state = isHost ? roomState : (clientState || {players:{}});
      const p = state.players[localId];
      yourCards.innerHTML = '';
      if (!p) return;
      (p.cards || []).forEach(c => {
        const d = document.createElement('div'); d.className='card'; d.textContent = `(${c.type}) ${c.text}`; yourCards.appendChild(d);
      });
    }

    /* --- countdown & voting --- */
    function startCountdown(endTime, duration=20) {
      turnInfo.style.display = 'block';
      votePanel.style.display = 'none';
      choosePanel.style.display = 'none';
      if (countdownTimer) clearInterval(countdownTimer);
      const start = Date.now();
      const totalMs = Math.max(1000, (endTime - start) > 0 ? (endTime - start) : duration*1000);
      function update() {
        const now = Date.now();
        const leftMs = Math.max(0, endTime - now);
        const sleft = Math.ceil(leftMs / 1000);
        timeLeft.textContent = sleft;
        const pct = Math.max(0, Math.min(1, leftMs / totalMs));
        ringFill.style.boxShadow = `inset 0 0 0 ${Math.round(6 + (1-pct)*54)}px rgba(255,255,255,0.06)`;
        if (now >= endTime) {
          clearInterval(countdownTimer);
          onCountdownComplete();
        }
      }
      update();
      countdownTimer = setInterval(update, 200);
    }

    function onCountdownComplete() {
      turnInfo.style.display = 'none';
      votePanel.style.display = 'block';
      voteYes.disabled = voteNo.disabled = false;
    }

    voteYes.onclick = ()=>{ sendVote(true); voteYes.disabled = voteNo.disabled = true; };
    voteNo.onclick = ()=>{ sendVote(false); voteYes.disabled = voteNo.disabled = true; };

    function sendVote(v) {
      if (isHost) {
        hostHandle(localId, 'vote', {vote: v});
      } else {
        const hostConn = Object.values(connMap)[0]; if (!hostConn) return alert('not connected');
        sendTo(hostConn, {type:'vote', payload:{vote:v}});
      }
    }

    /* --- choose targets UI --- */
    function showChooseTargets(players) {
      choosePanel.style.display = 'block';
      chooseList.innerHTML = '';
      Object.entries(players || {}).forEach(([pid, p])=>{
        if (pid === localId) return;
        const b = document.createElement('button'); b.className='btn'; b.textContent = p.name;
        b.onclick = ()=> {
          if (isHost) {
            hostHandle(localId, 'choose_target', {newTarget: pid});
          } else {
            const hostConn = Object.values(connMap)[0]; if (!hostConn) return alert('not connected');
            sendTo(hostConn, {type:'choose_target', payload:{newTarget: pid}});
          }
          choosePanel.style.display = 'none';
        };
        chooseList.appendChild(b);
      });
    }

    /* --- card input (asker) --- */
    function showCardInput(targetId) {
      // build modal
      const modal = document.createElement('div'); modal.className = 'modal';
      const box = document.createElement('div'); box.className = 'box';
      box.innerHTML = `<div><strong>It's your turn to ask</strong></div>
        <div class="muted small" style="margin-top:6px">Target: <strong>${(clientState && clientState.players && clientState.players[targetId] && clientState.players[targetId].name) || targetId}</strong></div>
        <div style="margin-top:10px"><input id="askText" placeholder="Enter a truth or a dare" style="width:100%;padding:8px;border-radius:6px;background:#111;border:1px solid #333;color:var(--fg)"></div>
        <div style="margin-top:8px;display:flex;gap:8px"><select id="askType"><option value="truth">Truth</option><option value="dare">Dare</option></select><div style="flex:1"></div><button id="sendAsk" class="btn">Send</button></div>
        <div style="margin-top:8px" class="muted small">When you send, the card appears to everyone and the timer starts.</div>`;
      modal.appendChild(box);
      document.body.appendChild(modal);
      const sendBtn = box.querySelector('#sendAsk');
      sendBtn.onclick = ()=> {
        const t = box.querySelector('#askText').value.trim();
        const tp = box.querySelector('#askType').value;
        if (!t) return alert('enter something');
        const card = {type:tp, text:t};
        // send to host
        if (isHost) {
          // host can call hostHandle directly as asker (localId)
          hostHandle(localId, 'present_card', {card, targetId});
        } else {
          const hostConn = Object.values(connMap)[0]; if (!hostConn) return alert('not connected');
          sendTo(hostConn, {type:'present_card', payload:{card, targetId}});
        }
        document.body.removeChild(modal);
      };
    }

    /* --- card display --- */
    function showPresentedCard(card) {
      cardDisplay.style.display = 'block';
      cardDisplay.innerHTML = `<div style="font-size:13px" class="muted small">From: <strong>${(clientState && clientState.players && clientState.players[card.asker] && clientState.players[card.asker].name) || card.asker}</strong> · To: <strong>${(clientState && clientState.players && clientState.players[card.targetId] && clientState.players[card.targetId].name) || card.targetId}</strong></div>
        <div style="margin-top:8px;font-size:16px"><strong>(${card.type.toUpperCase()})</strong> ${card.text}</div>`;
    }

    /* --- circle avatar render & arrow --- */
    function renderCirclePlayers(players, currentTarget) {
      // clear avatars
      circleArea.querySelectorAll('.avatar').forEach(n => n.remove());
      const entries = Object.entries(players || {});
      const n = entries.length;
      if (n === 0) return;
      const radius = 110;
      entries.forEach(([pid,p], idx) => {
        const angle = (idx / n) * Math.PI * 2 - Math.PI/2; // start top
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        const el = document.createElement('div'); el.className = 'avatar';
        el.style.left = `calc(50% + ${x}px - 42px)`; // offset half width (84/2)
        el.style.top = `calc(50% + ${y}px - 42px)`;
        el.innerHTML = `<div class="dot" style="background:${p.color}"></div><div class="label">${p.name}${pid===localId? ' (you)':''}</div>`;
        if (pid === currentTarget) {
          el.querySelector('.dot').style.boxShadow = '0 0 0 4px rgba(255,255,255,0.04), 0 0 14px rgba(255,255,255,0.03)';
        }
        circleArea.appendChild(el);
      });

      // point arrow toward currentTarget
      if (currentTarget && players[currentTarget]) {
        const idx = entries.findIndex(([pid])=> pid === currentTarget);
        if (idx >= 0) {
          const angleDeg = (idx / n) * 360;
          centerArrow.style.transform = `translate(-50%,-50%) rotate(${angleDeg}deg)`;
          centerArrow.style.display = 'block';
          return;
        }
      }
      centerArrow.style.display = 'none';
    }

    // create peer at load so id is ready quickly
    makePeer();
  </script>
</body>
</html>
