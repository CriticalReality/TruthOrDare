<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Truth or Dare — PeerJS Multiplayer (fixed)</title>
  <style>
    :root{--bg:#000;--fg:#ddd;--muted:#888}
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--fg)}
    .app{display:flex;flex-direction:column;height:100%;gap:12px;padding:18px}
    .center{margin:auto}
    .btn{background:#222;border:1px solid #444;padding:10px 14px;border-radius:8px;color:var(--fg);cursor:pointer;min-width:120px;transition:transform .12s ease,opacity .12s}
    .btn:hover{transform:translateY(-3px)}
    .muted{color:var(--muted)}
    input,select{background:#111;border:1px solid #333;padding:8px;border-radius:8px;color:var(--fg)}
    .menu{display:flex;gap:12px;align-items:center}
    .menu .box{background:rgba(255,255,255,0.02);padding:20px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .room{display:grid;grid-template-columns:300px 1fr 300px;gap:12px;align-items:start}
    .panel{background:rgba(255,255,255,0.02);padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}
    .players{display:flex;flex-direction:column;gap:8px}
    .player{display:flex;align-items:center;gap:8px;padding:8px;border-radius:8px}
    .swatch{width:36px;height:36px;border-radius:8px;flex:0 0 36px}
    .cards{display:flex;flex-direction:column;gap:8px}
    .card{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.02)}
    .timer{display:flex;align-items:center;gap:10px}
    .ring{width:64px;height:64px;border-radius:50%;position:relative}
    .ring .fill{position:absolute;inset:0;border-radius:50%;box-shadow:inset 0 0 0 6px rgba(255,255,255,0.06)}
    .count{font-size:20px}
    .fade-in{animation:fadeIn .28s ease both}
    @keyframes fadeIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:none}}
    @media (max-width:900px){.room{grid-template-columns:1fr;}.panel{width:100%}}
    footer{opacity:.6;font-size:13px}
    button:disabled{opacity:0.5;cursor:not-allowed}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1 style="margin:0">Truth or Dare — PeerJS Multiplayer</h1>
      <p class="muted">No backend required — uses PeerJS cloud for peer discovery and data connections.</p>
    </header>

    <main class="center">
      <div id="menu" class="menu box fade-in">
        <div>
          <div style="margin-bottom:8px">Display name</div>
          <input id="nameInput" placeholder="Your name" value="Player" />
        </div>
        <div style="display:flex;flex-direction:column;gap:8px">
          <button id="createBtn" class="btn">Create Room</button>
          <div style="display:flex;gap:8px;align-items:center;margin-top:6px">
            <input id="joinId" placeholder="Room ID" />
            <button id="joinBtn" class="btn">Join Room</button>
          </div>
        </div>
        <div style="display:flex;flex-direction:column;gap:8px">
          <label class="muted">Rounds</label>
          <select id="roundsSelect">
            <option value="3">3</option>
            <option value="5" selected>5</option>
            <option value="7">7</option>
          </select>
          <div class="muted" style="font-size:12px;margin-top:6px">Tip: copy the Room ID and paste in Discord for friends to join.</div>
        </div>
      </div>

      <div id="roomUI" style="display:none;width:95vw;max-width:1100px" class="fade-in">
        <div style="margin-bottom:10px;display:flex;justify-content:space-between;gap:12px;align-items:center">
          <div><strong>Room:</strong> <span id="roomIdDisplay"></span></div>
          <div class="muted">You are <span id="youName"></span> · <span id="youId"></span></div>
        </div>

        <div class="room">
          <div class="panel">
            <h3>Players</h3>
            <div id="playersList" class="players"></div>
            <div style="margin-top:8px"><button id="leaveBtn" class="btn">Leave Room</button></div>
          </div>

          <div class="panel">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:8px">
              <h3>Game Area</h3>
              <div style="display:flex;gap:8px;align-items:center">
                <label class="muted">Round</label>
                <div id="roundDisplay">0 / 0</div>
                <button id="startRoundBtn" class="btn">Start Round</button>
              </div>
            </div>

            <div id="mainStage" style="margin-top:12px">
              <div id="turnInfo" style="display:none">
                <div><strong>Target:</strong> <span id="targetName"></span></div>
                <div style="margin-top:8px" class="timer">
                  <div class="ring"><div id="ringFill" class="fill"></div></div>
                  <div><div class="count" id="timeLeft">0</div><div class="muted">seconds left</div></div>
                </div>
              </div>

              <div id="votePanel" style="display:none;margin-top:12px">
                <div class="muted">Vote: Did they complete the challenge?</div>
                <div style="display:flex;gap:8px;margin-top:8px">
                  <button class="btn" id="voteYes">Success</button>
                  <button class="btn" id="voteNo">Fail</button>
                </div>
              </div>

              <div id="chooseTargetPanel" style="display:none;margin-top:12px">
                <div class="muted">Choose next target</div>
                <div id="chooseList" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px"></div>
              </div>

              <div id="gameOver" style="display:none;margin-top:12px">
                <h3>Game Over</h3>
                <div id="winnerText" class="muted"></div>
              </div>
            </div>

          </div>

          <div class="panel">
            <h3>Your Cards</h3>
            <div style="display:flex;gap:8px;margin-bottom:8px">
              <input id="cardText" placeholder="Write a truth or dare" style="flex:1" />
              <select id="cardType"><option value="truth">Truth</option><option value="dare">Dare</option></select>
              <button id="addCardBtn" class="btn">Add</button>
            </div>
            <div id="yourCards" class="cards" style="max-height:320px;overflow:auto"></div>
            <hr style="opacity:.06;margin:10px 0" />
            <div class="muted" style="font-size:13px">Room colors</div>
            <div style="height:40px;display:flex;gap:8px;align-items:center;margin-top:6px">
              <div id="accentA" style="width:40px;border-radius:6px"></div>
              <div id="accentB" style="width:40px;border-radius:6px"></div>
            </div>
          </div>
        </div>

      </div>
    </main>

    <footer>Built with PeerJS cloud — open-source; save this file as index.html and host on GitHub Pages for easy sharing.</footer>
  </div>

  <!-- PeerJS CDN (kept as in your original) -->
  <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
  <script>
    /* --- utilities & UI refs --- */
    const qs = sel => document.querySelector(sel);
    const randColor = () => '#'+Math.floor(Math.random()*0xffffff).toString(16).padStart(6,'0');

    const menu = qs('#menu'), roomUI = qs('#roomUI');
    const nameInput = qs('#nameInput'), createBtn = qs('#createBtn'), joinBtn = qs('#joinBtn'), joinId = qs('#joinId');
    const roomIdDisplay = qs('#roomIdDisplay'), youName = qs('#youName'), youId = qs('#youId');
    const playersList = qs('#playersList'), yourCards = qs('#yourCards'), addCardBtn = qs('#addCardBtn'), cardText = qs('#cardText'), cardType = qs('#cardType');
    const startRoundBtn = qs('#startRoundBtn'), roundDisplay = qs('#roundDisplay');
    const turnInfo = qs('#turnInfo'), targetName = qs('#targetName'), timeLeft = qs('#timeLeft'), ringFill = qs('#ringFill');
    const votePanel = qs('#votePanel'), voteYes = qs('#voteYes'), voteNo = qs('#voteNo');
    const choosePanel = qs('#chooseTargetPanel'), chooseList = qs('#chooseList');
    const roundsSelect = qs('#roundsSelect'), leaveBtn = qs('#leaveBtn');
    const accentA = qs('#accentA'), accentB = qs('#accentB');
    const gameOver = qs('#gameOver'), winnerText = qs('#winnerText');

    /* --- network & state --- */
    let peer = null;
    let connMap = {}; // remotePeerId -> DataConnection (host: connections to clients)
    let isHost = false;
    let localId = null;
    let displayName = 'Player';

    let roomState = {
      id: null,
      players: {}, // peerId -> {name, cards:[], score:0, color}
      round: 0,
      maxRounds: 5,
      currentTarget: null,
      previousTarget: null,
      status: 'lobby' // 'lobby'|'running'|'voting'|'choose'|'over'
    };

    let clientState = null;

    let countdownTimer = null;

    /* --- Peer helpers --- */
    function makePeer() {
      if (peer) return;
      // create Peer with default options
      peer = new Peer();

      peer.on('open', id => {
        localId = id;
        youId.textContent = id;
        console.log('peer open', id);
      });

      // host accepts incoming connections
      peer.on('connection', conn => {
        // if not host, politely close
        if (!isHost) { conn.on('open', () => conn.close()); return; }
        setupConn(conn);
      });

      peer.on('error', err => {
        console.error('Peer error', err);
        // display in console; could surface to user UI if desired
      });

      peer.on('disconnected', ()=> console.warn('peer disconnected'));
      peer.on('close', ()=> console.warn('peer closed'));
    }

    function setupConn(conn) {
      conn.on('data', data => handleMessage(conn.peer, data));
      conn.on('open', ()=>{
        connMap[conn.peer] = conn;
        // send state to new client immediately
        if (isHost) {
          sendTo(conn, {type:'state', payload:roomState});
          renderPlayers();
        }
      });
      conn.on('close', ()=>{
        delete connMap[conn.peer];
        if (isHost) {
          // remove from room
          delete roomState.players[conn.peer];
          // if current or previous target removed, clear them safely
          if (roomState.currentTarget === conn.peer) roomState.currentTarget = null;
          if (roomState.previousTarget === conn.peer) roomState.previousTarget = null;
          broadcast({type:'state', payload:roomState});
          renderPlayers();
        }
      });
      conn.on('error', err => console.warn('conn error', err));
    }

    function connectToHost(hostId) {
      if (!peer || !localId) return alert('peer not ready yet');
      const c = peer.connect(hostId, {reliable:true});
      c.on('open', ()=>{
        setupConn(c);
        // announce join
        sendTo(c,{type:'join', payload:{name:displayName}});
      });
      c.on('error', e=>console.error('connect error', e));
    }

    function sendTo(connOrPeerId, msg) {
      // if string, treat as peerId -> connection map lookup
      if (typeof connOrPeerId === 'string') {
        const c = connMap[connOrPeerId];
        if (c && c.open) c.send(msg);
        return;
      }
      // DataConnection object
      if (connOrPeerId && connOrPeerId.open) connOrPeerId.send(msg);
    }

    function broadcast(msg) {
      // host only
      Object.values(connMap).forEach(c => { if (c.open) c.send(msg); });
    }

    /* --- message handling --- */
    function handleMessage(fromPeerId, msg) {
      try {
        const {type, payload} = msg || {};
        if (isHost) return hostHandle(fromPeerId, type, payload);
        return clientHandle(type, payload, fromPeerId);
      } catch(e){ console.error('msg handle err', e); }
    }

    /* Host-side handlers */
    function hostHandle(peerId, type, payload){
      if (type === 'join') {
        // add player
        if (!roomState.players[peerId]) {
          roomState.players[peerId] = { name: payload.name || 'Player', cards: [], score: 0, color: randColor() };
          // send updated state to all
          broadcast({type:'state', payload:roomState});
          renderPlayers();
        }
      } else if (type === 'add_card') {
        const card = {...payload.card, owner: peerId, id: Date.now() + Math.random()};
        if (roomState.players[peerId]) {
          roomState.players[peerId].cards.push(card);
          broadcast({type:'state', payload:roomState});
          renderPlayers();
        }
      } else if (type === 'start_turn') {
        // start turn came from host UI or a client request; but only host executes authoritative start
        const duration = payload.duration || 20;
        roomState.status = 'running';
        roomState.currentTarget = payload.targetId;
        roomState.round = payload.round || roomState.round;
        const endTime = Date.now() + duration*1000;
        broadcast({type:'start_turn', payload:{targetId: roomState.currentTarget, endTime, duration}});
        broadcast({type:'state', payload:roomState});
      } else if (type === 'vote') {
        roomState.votes = roomState.votes || {};
        roomState.votes[peerId] = payload.vote;
        const totalPlayers = Object.keys(roomState.players).length;
        if (Object.keys(roomState.votes).length >= totalPlayers) {
          const yes = Object.values(roomState.votes).filter(Boolean).length;
          const success = yes > (totalPlayers/2);
          if (success && roomState.currentTarget && roomState.players[roomState.currentTarget]) {
            roomState.players[roomState.currentTarget].score = (roomState.players[roomState.currentTarget].score || 0) + 1;
          }
          roomState.status = 'choose';
          broadcast({type:'vote_result', payload:{success, votes: roomState.votes}});
          broadcast({type:'state', payload:roomState});
          roomState.votes = {};
        }
      } else if (type === 'choose_target') {
        const newTarget = payload.newTarget;
        const prev = roomState.currentTarget;
        if (prev && roomState.players[prev] && roomState.players[prev].cards && roomState.players[prev].cards.length > 0) {
          const card = roomState.players[prev].cards.shift();
          if (card && roomState.players[newTarget]) roomState.players[newTarget].cards.push(card);
        }
        roomState.previousTarget = prev;
        roomState.currentTarget = newTarget;
        roomState.round = (roomState.round || 0) + 1;
        // check end condition
        if (roomState.round >= roomState.maxRounds) {
          roomState.status = 'over';
          // compute winner
          let winner = null; let top = -1;
          Object.entries(roomState.players).forEach(([pid,p]) => { if ((p.score||0) > top) { top = p.score; winner = {id: pid, name: p.name, score: p.score}; }});
          broadcast({type:'game_over', payload:{winner}});
          broadcast({type:'state', payload:roomState});
          return;
        }
        roomState.status = 'running';
        const duration = 20;
        const endTime = Date.now() + duration*1000;
        broadcast({type:'start_turn', payload:{targetId: newTarget, endTime, duration}});
        broadcast({type:'state', payload:roomState});
      }
    }

    /* Client-side handlers */
    function clientHandle(type, payload, fromPeerId) {
      if (type === 'state') {
        clientState = payload;
        // sync UI
        renderPlayers();
        updateYourCards();
        roundDisplay.textContent = (payload.round || 0) + ' / ' + (payload.maxRounds || 0);
        // update accents to stable colors (take first two players or stored colors)
        const players = payload.players || {};
        const colors = Object.values(players).map(p => p.color).filter(Boolean);
        accentA.style.background = colors[0] || '#444';
        accentB.style.background = colors[1] || '#666';
      } else if (type === 'start_turn') {
        clientState = clientState || {};
        clientState.currentTarget = payload.targetId;
        // set nice label for target
        const tPlayers = clientState.players || {};
        const label = (tPlayers[payload.targetId] && tPlayers[payload.targetId].name) || (payload.targetId === localId ? 'You' : payload.targetId);
        targetName.textContent = label;
        startCountdown(payload.endTime, payload.duration || 20);
      } else if (type === 'vote_result') {
        const s = payload.success;
        alert('Vote result: ' + (s ? 'SUCCESS' : 'FAILED'));
      } else if (type === 'game_over') {
        gameOver.style.display = 'block';
        winnerText.textContent = payload.winner ? (payload.winner.name + ' wins with ' + payload.winner.score + ' points') : 'No winner';
      }
    }

    /* --- UI actions --- */
    createBtn.onclick = async ()=> {
      displayName = nameInput.value.trim() || 'Player';
      isHost = true;
      makePeer();
      // wait for id to be available
      await waitForLocalId();
      roomState.id = localId;
      roomState.maxRounds = parseInt(roundsSelect.value, 10) || 5;
      roomState.players[localId] = { name: displayName, cards: [], score: 0, color: randColor() };

      // show UI
      menu.style.display = 'none'; roomUI.style.display = 'block';
      roomIdDisplay.textContent = localId; youName.textContent = displayName; youId.textContent = localId;
      renderPlayers();
      // host does not need a DataConnection to self; state is already set
    };

    joinBtn.onclick = ()=> {
      displayName = nameInput.value.trim() || 'Player';
      isHost = false;
      makePeer();
      const id = joinId.value.trim(); if (!id) return alert('enter room id');
      waitForLocalId().then(()=> {
        connectToHost(id);
        menu.style.display = 'none'; roomUI.style.display = 'block';
        roomIdDisplay.textContent = id; youName.textContent = displayName; youId.textContent = localId;
      });
    };

    async function waitForLocalId(){
      if (localId) return;
      return new Promise(r => {
        const t = setInterval(()=>{ if (localId){ clearInterval(t); r(); } }, 50);
      });
    }

    addCardBtn.onclick = ()=> {
      const text = cardText.value.trim(); if (!text) return;
      const ct = cardType.value;
      const card = {type:ct, text};
      if (isHost) {
        roomState.players[localId].cards.push({...card, id: Date.now()+Math.random(), owner: localId});
        broadcast({type:'state', payload: roomState});
        renderPlayers(); updateYourCards();
      } else {
        const hostConn = Object.values(connMap)[0];
        if (!hostConn) return alert('not connected to host');
        sendTo(hostConn, {type:'add_card', payload:{card}});
      }
      cardText.value = '';
    };

    startRoundBtn.onclick = ()=> {
      if (!isHost) return alert('only host may start rounds');
      const pids = Object.keys(roomState.players || {});
      if (pids.length < 2) return alert('need at least 2 players');
      // choose a target that is not last target if possible
      let choices = pids.filter(id => id !== roomState.previousTarget);
      if (choices.length === 0) choices = pids;
      const target = choices[Math.floor(Math.random()*choices.length)];
      const duration = 20;
      roomState.round = (roomState.round || 0) + 1;
      roomState.currentTarget = target;
      roomState.status = 'running';
      roomState.maxRounds = parseInt(roundsSelect.value,10) || roomState.maxRounds;
      const endTime = Date.now() + duration*1000;
      broadcast({type:'start_turn', payload:{targetId: target, endTime, duration, round: roomState.round}});
      broadcast({type:'state', payload:roomState});
    };

    leaveBtn.onclick = ()=> {
      location.reload();
    };

    /* --- rendering --- */
    function renderPlayers() {
      const state = isHost ? roomState : (clientState || {players:{}});

      playersList.innerHTML = '';
      Object.entries(state.players || {}).forEach(([pid, p]) => {
        const el = document.createElement('div'); el.className = 'player';
        const youTag = (pid === localId) ? ' <span class="muted">(you)</span>' : '';
        el.innerHTML = `<div class="swatch" style="background:${p.color}"></div><div style="flex:1"><div><strong>${p.name}</strong> ${youTag}</div><div class="muted" style="font-size:12px">Score: ${p.score||0} · Cards: ${p.cards? p.cards.length:0}</div></div>`;
        playersList.appendChild(el);
      });

      // show choose target if in choose state and currentTarget is this client
      if (!isHost && clientState && clientState.status === 'choose' && clientState.currentTarget === localId) {
        showChooseTargets(clientState.players);
      } else {
        choosePanel.style.display = 'none';
      }

      // stable accents (use first two players colors if available)
      const colors = Object.values(state.players || {}).map(p => p.color).filter(Boolean);
      accentA.style.background = colors[0] || '#333';
      accentB.style.background = colors[1] || '#555';
    }

    function updateYourCards() {
      const state = isHost ? roomState : (clientState || {players:{}});
      const p = state.players[localId];
      yourCards.innerHTML = '';
      if (!p) return;
      (p.cards || []).forEach(c => {
        const d = document.createElement('div'); d.className='card'; d.textContent = `(${c.type}) ${c.text}`; yourCards.appendChild(d);
      });
    }

    /* --- countdown & voting --- */
    function startCountdown(endTime, duration=20) {
      turnInfo.style.display = 'block';
      votePanel.style.display = 'none';
      choosePanel.style.display = 'none';
      // set label for target if we have players info
      const label = (clientState && clientState.players && clientState.players[ (clientState.currentTarget || '') ] && clientState.players[clientState.currentTarget].name) || (isHost && roomState.players && roomState.players[roomState.currentTarget] && roomState.players[roomState.currentTarget].name) || '';
      if (label) targetName.textContent = label;

      if (countdownTimer) clearInterval(countdownTimer);
      const start = Date.now();
      const totalMs = Math.max(1000, (endTime - start) > 0 ? (endTime - start) : duration*1000);
      function update() {
        const now = Date.now();
        const leftMs = Math.max(0, endTime - now);
        const sleft = Math.ceil(leftMs / 1000);
        timeLeft.textContent = sleft;
        const pct = Math.max(0, Math.min(1, leftMs / totalMs));
        // thickness visual mapping
        ringFill.style.boxShadow = `inset 0 0 0 ${Math.round(6 + (1-pct)*54)}px rgba(255,255,255,0.06)`;
        if (now >= endTime) {
          clearInterval(countdownTimer);
          onCountdownComplete();
        }
      }
      update();
      countdownTimer = setInterval(update, 200);
    }

    function onCountdownComplete() {
      turnInfo.style.display = 'none';
      votePanel.style.display = 'block';
      voteYes.disabled = voteNo.disabled = false;
    }

    voteYes.onclick = ()=>{ sendVote(true); voteYes.disabled = voteNo.disabled = true; };
    voteNo.onclick = ()=>{ sendVote(false); voteYes.disabled = voteNo.disabled = true; };

    function sendVote(v) {
      if (isHost) {
        hostHandle(localId, 'vote', {vote: v});
      } else {
        const hostConn = Object.values(connMap)[0]; if (!hostConn) return alert('not connected');
        sendTo(hostConn, {type:'vote', payload:{vote:v}});
      }
    }

    /* --- choose targets UI --- */
    function showChooseTargets(players) {
      choosePanel.style.display = 'block';
      chooseList.innerHTML = '';
      Object.entries(players || {}).forEach(([pid, p])=>{
        if (pid === localId) return;
        const b = document.createElement('button'); b.className='btn'; b.textContent = p.name;
        b.onclick = ()=> {
          if (isHost) {
            hostHandle(localId, 'choose_target', {newTarget: pid});
          } else {
            const hostConn = Object.values(connMap)[0]; if (!hostConn) return alert('not connected');
            sendTo(hostConn, {type:'choose_target', payload:{newTarget: pid}});
          }
          choosePanel.style.display = 'none';
        };
        chooseList.appendChild(b);
      });
    }

    // create peer at load so id is ready quickly
    makePeer();
  </script>
</body>
</html>
